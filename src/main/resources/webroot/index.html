<html lang="en">
<head>
  <title>X</title>
  <script src="sockjs.min.js"></script>
  <script src="vertx-eventbus.js"></script>
</head>

<body>

Open the dev tools to see this code running.
<input type="text" placeholder="Type something and send" id="chatInput"/>

<div id="output"></div>

<script>
  function makeUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (a, b) {
      return b = Math.random() * 16, (a === 'y' ? b & 3 | 8 : b | 0).toString(16);
    });
  }

  const output = document.getElementById("output");
  const log = msg => output.innerHTML += `<br>${msg}`;
  
  const eb = new EventBus("http://localhost:8888/eventbus");

  eb.onopen = function () {
    // sockjs connection is ready!
    console.log('Successfully connected to signaling server !');

    let connectionsCounter = 0;

    const webrtcId = makeUUID();

    // TODO: make this a configurable option
    const config = {
      iceServers: [{
        urls: "stun:stun.1.google.com:19302"
      }]
    };

    // each client needs to keep track of all known peers,
    // for this we can create a map between a peerId and a RTCPeerConnection + DataChannel
    // the simplest way is to use a JS Object
    const peers = {};


    function Peer() {
      this.pc = new RTCPeerConnection(config);
      this.dc = this.pc.createDataChannel("eventbus", {
        negotiated: true,
        // TODO: this will be a counter that increments for each connection
        id: ++connectionsCounter
      });

      this.pc.onconnectionstatechange = handleChange;
      this.pc.oniceconnectionstatechange = handleChange;

      this.dc.onmessage = e => {console.log('Received ', e.data); log(e.data)};
      this.pc.oniceconnectionstatechange = e => console.log(this.pc.iceConnectionState);
    }


    // const pc = new RTCPeerConnection(config);
    // // TODO: this isn't correct, for now we only connect to 1 node, but later
    // //       we will connect to multiple nodes
    //
    // // HERE is where you need to keep a map of webrtcId to remote data channels
    // // for each channel you open, or better, for each webrtcId you know you have a custom "dc".
    //
    // // later you can refer to the specific dc as "dc[webrtcId]" as messages should alays include a webrtcId.
    // // this avoids you having to keep state on the java side
    // const dc = pc.createDataChannel("eventbus", {
    //   negotiated: true,
    //   // TODO: this will be a counter that increments for each connection
    //   id: ++connectionsCounter
    // });

    // Some debug helper functions
    function handleChange(evt) {
      console.log(new Date().toISOString() + ': ConnectionState: ' + peers[webrtcId].pc.connectionState + ' IceConnectionState: ' + peers[webrtcId].pc.iceConnectionState);
    }


    // a new client joined the cluster
    eb.registerHandler('webrtc.signaling', function (err, msg) {
      console.log('2. A new browser has joined the cluster', msg);

      // TODO: we should not answer to our own messages
      if (msg.body.webrtcId === webrtcId) {
        return;
      }
      
      const remoteWebrtcId = msg.body.webrtcId;

      if (msg.body.type === 'join') {
        // I think here we should check if the type of the message is join since we want to send an offer
        // only if the node is new otherwise it is most likely a broadcast message
      }
    

      // when there is a new connection:
      peers[remoteWebrtcId] = new Peer();

      // We need to return when the message webrtcId is the same as ours
      console.log('3. Create an offer, using webrtc', remoteWebrtcId, peers);
      // reply with a webrtc offer
      peers[remoteWebrtcId].pc.createOffer().then(offer => {
        peers[remoteWebrtcId].pc.setLocalDescription(offer).then(() => {
          peers[remoteWebrtcId].pc.onicecandidate = ({candidate}) => {
            if (candidate) {return;}
            console.log('4. We reply to the caller browser with the offer');

            eb.send(msg.body.address, {
                type: "offer",
                webrtcId: webrtcId,
                sdp: peers[remoteWebrtcId].pc.localDescription.sdp
              })
              .then(reply => {
                console.log('8. We should have received a answer specific for this browswer');
                console.log('9. We now need to finish the handshake');

                // TODO: finish the handshake

                peers[remoteWebrtcId].pc.setRemoteDescription({
                  type: "answer",
                  sdp: reply.body.sdp
                });
              }).catch(err => console.log('Error replying to other node\'s offer', err))
          };
        }).catch(er => console.log('Err ', er))
      }).catch(err => console.log('Error occured in creating offer ' + err));
    });

    // a different client is offering a webrtc offer
    eb.registerHandler('webrtc.' + webrtcId, function (err, msg) {

      const remoteWebrtcId = msg.body.webrtcId;

      console.log('5. A offer for this browser was received');
      
      peers[remoteWebrtcId] = new Peer();
      // TODO: apply the sdp offer to the peer connection
      peers[remoteWebrtcId].pc.setRemoteDescription({
        type: "offer",
        sdp: msg.body.sdp
      }).then(() => {
        // TODO: create an answer and send it back to the other client
        console.log('6. Create an answer for the specific offer');

        peers[remoteWebrtcId].pc.createAnswer().then(answer => {
          peers[remoteWebrtcId].pc.setLocalDescription(answer).then(() => {
            peers[remoteWebrtcId].pc.onicecandidate = ({candidate}) => {
              if (candidate) return;
              console.log('7. We reply to the specific browser using the reply function with the anwser');
              // TODO: using msg.reply() to send the answer back to the other client
              msg.reply({
                type: "answer",
                webrtcId: webrtcId,
                sdp: peers[remoteWebrtcId].pc.localDescription.sdp
              });
            };
          });
        });
      });
    });

    console.log('1. Start the signaling process');
    // start the webrtc handshake
    eb.publish('webrtc.signaling', {
      type: "join",
      webrtcId: webrtcId,
      address: "webrtc." + webrtcId
    });

    const chatInput = document.getElementById('chatInput');
    chatInput.onkeypress = function (e) {
        if (e.keyCode !== 13)
          return;
        Object.entries(peers).forEach(([key, value]) => {
            value.dc.send(chatInput.value);
        });
//        dc.send(chatInput.value);
        log(chatInput.value);
        chatInput.value = '';
    };
    // // 0. we start here, follow the rest of the logic on the server java side
    // document.getElementById('sendBtn').addEventListener('click', (event) => {
    //
    //
    // });
  };
</script>

</body>
</html>
